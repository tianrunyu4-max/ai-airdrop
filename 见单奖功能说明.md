# 🎁 见单奖功能说明

## 📋 功能概述

**见单奖（Order Bonus）**：直推关系链5层，下线每次对碰成功，上级直推链的5个人各获得1U奖励。

---

## 🎯 奖励规则

### 基本规则

- **层级数量**：5层直推关系链
- **触发条件**：下线对碰成功
- **奖励金额**：每层1U × 对碰组数
- **发放对象**：直推上级（不是Binary树上级）

### 示例说明

```
A (创世人)
├─ B (A的直推)
   ├─ C (B的直推)
      ├─ D (C的直推)
         ├─ E (D的直推)
            ├─ F (E的直推)
               └─ G (F的直推)
```

**场景1：G对碰1组**
```
G 对碰1组成功 →
  F 获得 1U (第1层)
  E 获得 1U (第2层)
  D 获得 1U (第3层)
  C 获得 1U (第4层)
  B 获得 1U (第5层)
  A 不获得（超过5层）
  
总发放：5U
```

**场景2：G对碰3组**
```
G 对碰3组成功 →
  F 获得 3U (第1层，3组 × 1U)
  E 获得 3U (第2层，3组 × 1U)
  D 获得 3U (第3层，3组 × 1U)
  C 获得 3U (第4层，3组 × 1U)
  B 获得 3U (第5层，3组 × 1U)
  
总发放：15U
```

**场景3：E对碰2组**
```
E 对碰2组成功 →
  D 获得 2U (第1层)
  C 获得 2U (第2层)
  B 获得 2U (第3层)
  A 获得 2U (第4层)
  (没有第5层上级)
  
总发放：8U
```

---

## 💻 技术实现

### 1. 代码位置

**文件：** `src/services/BinaryService.ts`

**函数：** `triggerOrderBonus(triggerId: string, pairsCount: number)`

### 2. 调用时机

在 `calculatePairing()` 函数中，对碰奖励发放后：

```typescript
// 发放对碰奖
await WalletManager.add(userId, pairingBonus, ...)

// 触发平级奖励
await this.triggerLevelBonus(userId, pairsCount)

// 🎁 触发见单奖（新增）
await this.triggerOrderBonus(userId, pairsCount)

// 检查复投
await this.checkReinvestRequired(userId)
```

### 3. 核心代码

```typescript
/**
 * 🎁 触发见单奖（直推链5层，每层1U）
 */
private static async triggerOrderBonus(
  triggerId: string,
  pairsCount: number
): Promise<void> {
  const ORDER_BONUS_DEPTH = 5  // 5层
  const ORDER_BONUS_PER_PAIR = 1  // 每组1U

  // 获取触发者信息
  const { data: triggerUser } = await supabase
    .from('users')
    .select('id, username, inviter_id')
    .eq('id', triggerId)
    .single()

  if (!triggerUser?.inviter_id) return

  // 向上追溯5层直推链
  let currentUserId = triggerUser.inviter_id
  let generation = 1

  while (currentUserId && generation <= ORDER_BONUS_DEPTH) {
    const { data: upline } = await supabase
      .from('users')
      .select('id, username, inviter_id')
      .eq('id', currentUserId)
      .single()

    if (!upline) break

    // 发放奖励
    const orderBonus = ORDER_BONUS_PER_PAIR * pairsCount

    await WalletManager.add(
      upline.id,
      orderBonus,
      'order_bonus',
      `见单奖（第${generation}层）：下线${triggerUser.username}对碰${pairsCount}组 × 1U`
    )

    // 记录到 order_bonuses 表
    await supabase.from('order_bonuses').insert({
      user_id: upline.id,
      trigger_user_id: triggerUser.id,
      generation: generation,
      pairs: pairsCount,
      amount: orderBonus,
      trigger_username: triggerUser.username
    })

    // 更新统计
    await supabase
      .from('binary_members')
      .update({
        total_order_bonus: supabase.raw(`COALESCE(total_order_bonus, 0) + ${orderBonus}`),
        total_earnings: supabase.raw(`total_earnings + ${orderBonus}`)
      })
      .eq('user_id', upline.id)

    // 继续向上
    currentUserId = upline.inviter_id
    generation++
  }
}
```

---

## 🗄️ 数据库变更

### 1. binary_members 表添加字段

```sql
ALTER TABLE binary_members
ADD COLUMN IF NOT EXISTS total_order_bonus DECIMAL(10, 2) DEFAULT 0 NOT NULL;

COMMENT ON COLUMN binary_members.total_order_bonus IS '见单奖总额';
```

### 2. 创建 order_bonuses 表

```sql
CREATE TABLE order_bonuses (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id),
  trigger_user_id UUID NOT NULL REFERENCES users(id),
  generation INT NOT NULL CHECK (generation >= 1 AND generation <= 5),
  pairs INT NOT NULL DEFAULT 1,
  amount DECIMAL(10, 2) NOT NULL DEFAULT 1.00,
  trigger_username VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_order_bonuses_user_id ON order_bonuses(user_id);
CREATE INDEX idx_order_bonuses_trigger_user_id ON order_bonuses(trigger_user_id);
```

**字段说明：**
- `user_id`: 获得奖励的用户
- `trigger_user_id`: 触发对碰的下线用户
- `generation`: 层级（1-5）
- `pairs`: 对碰组数
- `amount`: 奖励金额
- `trigger_username`: 触发者用户名（便于查询）

---

## 📊 查询示例

### 查看某用户的见单奖记录

```sql
SELECT 
  ob.id,
  ob.generation AS 层级,
  ob.trigger_username AS 触发者,
  ob.pairs AS 对碰组数,
  ob.amount AS 奖励金额,
  ob.created_at AS 获得时间
FROM order_bonuses ob
WHERE ob.user_id = 'USER_ID'
ORDER BY ob.created_at DESC
LIMIT 20;
```

### 查看某用户触发的见单奖（给了多少人）

```sql
SELECT 
  u.username AS 获得者,
  ob.generation AS 层级,
  ob.pairs AS 对碰组数,
  ob.amount AS 奖励金额,
  ob.created_at AS 时间
FROM order_bonuses ob
JOIN users u ON ob.user_id = u.id
WHERE ob.trigger_user_id = 'USER_ID'
ORDER BY ob.generation ASC, ob.created_at DESC;
```

### 统计见单奖总额

```sql
SELECT 
  user_id,
  COUNT(*) AS 获得次数,
  SUM(amount) AS 总金额,
  AVG(generation) AS 平均层级
FROM order_bonuses
GROUP BY user_id
ORDER BY SUM(amount) DESC
LIMIT 10;
```

---

## 💰 收益对比

### 旧系统（无见单奖）

```
用户A直推B, B直推C, C对碰1组：
- C获得：8.5U (对碰奖)
- B获得：0U (无见单奖)
- A获得：0U (无见单奖)
```

### 新系统（有见单奖）

```
用户A直推B, B直推C, C对碰1组：
- C获得：8.5U (对碰奖)
- B获得：1U (见单奖第1层)
- A获得：1U (见单奖第2层)

总发放：10.5U
```

### 5层完整示例

```
A→B→C→D→E→F (6人直推链)
F 对碰10组：

F的收益：
- 对碰奖：85U (10组 × 8.5U)
- 见单奖：0U

E的收益：
- 见单奖：10U (第1层)

D的收益：
- 见单奖：10U (第2层)

C的收益：
- 见单奖：10U (第3层)

B的收益：
- 见单奖：10U (第4层)

A的收益：
- 见单奖：10U (第5层)

总发放：
- 对碰奖：85U
- 见单奖：50U (5人 × 10U)
- 合计：135U
```

---

## 🎯 业务价值

### 1. 激励推广

- 推广更多下线 = 更多见单奖机会
- 5层深度鼓励团队裂变
- 被动收入，躺赚模式

### 2. 增强粘性

- 上级关心下级业绩（因为有见单奖）
- 主动帮助下级成长
- 团队氛围更好

### 3. 公平分配

- 不区分A/B区，只看直推关系
- 每层奖励相同（1U）
- 简单透明

---

## ⚙️ 配置参数

### 当前配置

```typescript
const ORDER_BONUS_DEPTH = 5  // 直推链层数
const ORDER_BONUS_PER_PAIR = 1  // 每组每层奖励（U）
```

### 可调整项

如果需要修改配置，在 `triggerOrderBonus()` 函数中：

1. **修改层数**：
   ```typescript
   const ORDER_BONUS_DEPTH = 3  // 改为3层
   ```

2. **修改奖励**：
   ```typescript
   const ORDER_BONUS_PER_PAIR = 0.5  // 改为每层0.5U
   ```

3. **添加条件**：
   ```typescript
   // 例如：需要直推≥2人才能获得见单奖
   if (upline.direct_referral_count < 2) {
     continue // 跳过不符合条件的上级
   }
   ```

---

## 🧪 测试步骤

### 1. 准备测试数据

```sql
-- 创建测试用户链
-- A → B → C → D → E → F

-- 注册用户A（创世人）
-- 注册用户B（邀请人：A）
-- 注册用户C（邀请人：B）
-- 注册用户D（邀请人：C）
-- 注册用户E（邀请人：D）
-- 注册用户F（邀请人：E）
```

### 2. 触发对碰

```typescript
// 让F购买AI学习卡（加入Binary系统）
// 触发F的对碰（手动或自动）
await BinaryService.calculatePairing('F_USER_ID')
```

### 3. 验证结果

```sql
-- 查看F的对碰奖
SELECT * FROM pairing_bonuses WHERE user_id = 'F_USER_ID';

-- 查看见单奖记录
SELECT * FROM order_bonuses WHERE trigger_user_id = 'F_USER_ID';

-- 查看E, D, C, B, A的余额变化
SELECT username, u_balance FROM users 
WHERE id IN ('E_ID', 'D_ID', 'C_ID', 'B_ID', 'A_ID');
```

**预期结果：**
- F: 获得对碰奖8.5U（或更多）
- E: 获得见单奖1U
- D: 获得见单奖1U
- C: 获得见单奖1U
- B: 获得见单奖1U
- A: 获得见单奖1U

---

## 📝 部署步骤

### 1. 执行数据库迁移

在 Supabase SQL Editor 中执行：

```sql
-- 运行 supabase/migrations/add_order_bonus_field.sql
```

### 2. 部署代码

```bash
git add src/services/BinaryService.ts
git add supabase/migrations/add_order_bonus_field.sql
git commit -m "feat: 新增见单奖功能 - 直推链5层每层1U"
git push
```

### 3. 重启服务

```bash
# 如果使用 Vercel
vercel --prod

# 如果使用本地
npm run build
npm run preview
```

### 4. 验证功能

- 注册测试用户
- 建立直推关系链
- 触发对碰
- 查看见单奖记录

---

## ⚠️ 注意事项

### 1. 性能考虑

- 每次对碰需要追溯5层上级
- 5次数据库查询 + 5次钱包操作
- 如果对碰频繁，考虑异步处理

### 2. 错误处理

- 已添加 try-catch 包裹
- 见单奖失败不影响对碰奖发放
- 记录错误日志便于排查

### 3. 数据一致性

- 使用事务保证原子性
- 钱包余额和统计字段同步更新
- 记录详细日志便于审计

---

## 🎊 完成状态

### ✅ 已完成

- [x] 实现 `triggerOrderBonus()` 函数
- [x] 在对碰奖励后调用
- [x] 添加数据库字段 `total_order_bonus`
- [x] 创建 `order_bonuses` 记录表
- [x] 添加错误处理和日志
- [x] 编写功能说明文档

### ⏳ 待测试

- [ ] 创建测试用户链
- [ ] 触发对碰验证奖励
- [ ] 检查数据库记录
- [ ] 验证余额变化

### 📈 可优化

- [ ] 添加后台管理界面（查看见单奖统计）
- [ ] 在用户端显示见单奖收益
- [ ] 添加见单奖排行榜
- [ ] 优化性能（批量处理）

---

**🎉 见单奖功能已完成！5层直推链，躺赚见单奖！** 💰

---

**创建时间：** 2025-10-18  
**功能状态：** ✅ 代码已完成，待测试  
**奖励规则：** 5层 × 1U × 对碰组数

