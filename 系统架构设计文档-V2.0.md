# 🏗️ AI科技创薪系统架构设计文档 V2.0

> **创建时间：** 2025-10-26  
> **状态：** 架构设计阶段  
> **目标：** 理清所有业务逻辑，避免越改越乱

---

## 📋 目录

1. [核心业务模块](#核心业务模块)
2. [数据表设计](#数据表设计)
3. [直推关系系统](#直推关系系统)
4. [积分释放系统](#积分释放系统)
5. [Binary对碰系统](#binary对碰系统)
6. [数据流转图](#数据流转图)

---

## 🎯 核心业务模块

### 模块关系图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户生命周期                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  注册(游客) → 充值U → 升级AI代理 → 激活学习卡 → 每日签到  │
│     ↓           ↓         ↓            ↓           ↓        │
│  无邀请关系   100U      建立直推关系   消耗100积分  释放积分│
│                         ↓                                    │
│                    加入Binary系统                            │
│                         ↓                                    │
│                   开始获得奖励                               │
│                    ├─ 见单奖（直推）                        │
│                    ├─ 对碰奖（Binary）                      │
│                    ├─ 平级奖（Binary）                      │
│                    └─ 分红奖（Binary）                      │
└─────────────────────────────────────────────────────────────┘
```

---

## 📊 数据表设计

### 1️⃣ **users（用户表）** - 基础信息

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username VARCHAR(50) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  
  -- 余额信息
  u_balance DECIMAL(20, 2) DEFAULT 0,           -- U余额（可提现）
  points_balance DECIMAL(20, 2) DEFAULT 0,      -- 总积分余额（只读，由触发器计算）
  transfer_points DECIMAL(20, 2) DEFAULT 0,     -- 互转积分（可用于激活学习卡、互转）
  frozen_balance DECIMAL(20, 2) DEFAULT 0,      -- 冻结余额
  
  -- 身份信息
  is_agent BOOLEAN DEFAULT false,               -- 是否AI代理
  is_admin BOOLEAN DEFAULT false,               -- 是否管理员
  agent_paid_at TIMESTAMPTZ,                    -- 成为代理时间
  
  -- 邀请信息
  invite_code VARCHAR(20) UNIQUE NOT NULL,      -- 我的邀请码
  
  -- 时间戳
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 关键索引
CREATE INDEX idx_users_is_agent ON users(is_agent);
CREATE INDEX idx_users_invite_code ON users(invite_code);

-- ⚠️ 注意：inviter_id 已移除，使用独立的 referral_relationships 表
```

### 2️⃣ **referral_relationships（直推关系表）** - ⭐ 核心新增

```sql
CREATE TABLE referral_relationships (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- 关系双方（都必须是AI代理）
  referrer_id UUID NOT NULL REFERENCES users(id),  -- 推荐人（上级）
  referee_id UUID NOT NULL REFERENCES users(id),   -- 被推荐人（下级）
  
  -- 关系建立时间
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- 状态
  is_active BOOLEAN DEFAULT true,                  -- 关系是否有效
  
  -- 唯一约束：一个人只能有一个推荐人
  UNIQUE(referee_id)
);

-- 索引
CREATE INDEX idx_referral_referrer ON referral_relationships(referrer_id);
CREATE INDEX idx_referral_referee ON referral_relationships(referee_id);
CREATE INDEX idx_referral_active ON referral_relationships(is_active);

-- 注释
COMMENT ON TABLE referral_relationships IS '直推关系表：记录AI代理之间的推荐关系';
COMMENT ON COLUMN referral_relationships.referrer_id IS '推荐人ID（邀请别人的人）';
COMMENT ON COLUMN referral_relationships.referee_id IS '被推荐人ID（被邀请的人）';
```

**为什么需要独立的直推关系表？**

1. ✅ **业务清晰**：直推关系是业务关系，应该独立管理
2. ✅ **查询高效**：专门的表，查询直推列表速度快
3. ✅ **历史追溯**：可以记录关系建立时间、状态变化
4. ✅ **扩展性强**：未来可以加字段（如见单奖统计、关系失效等）

### 3️⃣ **binary_members（Binary对碰系统表）** - 技术关系

```sql
CREATE TABLE binary_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE NOT NULL REFERENCES users(id),
  
  -- Binary系统的排线关系（技术关系，系统自动分配）
  upline_id UUID REFERENCES users(id),           -- 系统上级（自动排线）
  position_side VARCHAR(1) CHECK (position_side IN ('A', 'B')),
  position_depth INTEGER DEFAULT 1,
  
  -- 区域业绩统计
  a_side_count INTEGER DEFAULT 0,                -- A区业绩
  b_side_count INTEGER DEFAULT 0,                -- B区业绩
  a_side_pending INTEGER DEFAULT 0,              -- A区待对碰
  b_side_pending INTEGER DEFAULT 0,              -- B区待对碰
  
  -- 订单数（一点多单制）
  order_count INTEGER DEFAULT 1,
  
  -- 奖励统计
  total_pairing_bonus DECIMAL(20, 2) DEFAULT 0,  -- 对碰奖总额
  total_level_bonus DECIMAL(20, 2) DEFAULT 0,    -- 平级奖总额
  total_dividend DECIMAL(20, 2) DEFAULT 0,       -- 分红总额
  total_earnings DECIMAL(20, 2) DEFAULT 0,       -- 总收益
  
  -- 状态
  is_active BOOLEAN DEFAULT true,
  reinvest_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ⚠️ 关键区别：
-- referral_relationships.referrer_id = 业务推荐人（直推关系）
-- binary_members.upline_id = 系统排线上级（可能不是同一个人）
```

### 4️⃣ **learning_cards（学习卡表）**

```sql
CREATE TABLE learning_cards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- 积分信息
  total_points DECIMAL(20, 2) DEFAULT 300,       -- 总积分（100*3倍）
  released_points DECIMAL(20, 2) DEFAULT 0,      -- 已释放积分
  
  -- 状态
  status VARCHAR(20) DEFAULT 'active',           -- active, completed, expired
  is_active BOOLEAN DEFAULT true,
  
  -- 释放信息
  last_release_date DATE,                        -- 最后释放日期
  last_checkin_date DATE,                        -- 最后签到日期
  
  -- 时间
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,                        -- 出局时间
  
  -- 元数据
  metadata JSONB                                 -- 额外信息
);
```

### 5️⃣ **transactions（交易流水表）**

```sql
CREATE TABLE transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- 交易信息
  type VARCHAR(50) NOT NULL,                     -- 交易类型
  amount DECIMAL(20, 2) NOT NULL,                -- 金额
  balance_after DECIMAL(20, 2),                  -- 余额（交易后）
  
  -- 描述
  description VARCHAR(500),                      -- ✅ 扩展到500字符
  
  -- 关联信息
  related_user_id UUID REFERENCES users(id),     -- 关联用户
  currency VARCHAR(20) DEFAULT 'U',              -- 货币类型
  
  -- 元数据
  metadata JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 交易类型定义
-- 'agent_purchase'      - 购买AI代理（-30U）
-- 'binary_auto_gift'    - Binary系统赠送积分（+100积分）
-- 'card_purchase'       - 购买学习卡（-8U或-100积分）
-- 'daily_release'       - 每日释放（+U或+积分）
-- 'pairing_bonus'       - 对碰奖（+U）
-- 'level_bonus'         - 平级奖（+U）
-- 'dividend'            - 分红（+U）
-- 'transfer_out'        - 转出（-U或-积分）
-- 'transfer_in'         - 转入（+U或+积分）
-- 'recharge'            - 充值（+U）
-- 'withdraw'            - 提现（-U）
```

---

## 👥 直推关系系统

### 核心概念

```
直推关系（Referral Relationship）= 业务推荐关系
- 谁邀请我升级AI代理？
- 我的直推团队有多少人？
- 用于：见单奖、加速释放率计算
```

### 建立时机

```
❌ 错误：注册时填写邀请码 → 建立关系
✅ 正确：升级AI代理时填写邀请码 → 建立关系

原因：
1. 只有付费AI代理才参与奖励体系
2. 免费用户不应该占用邀请关系
3. 减轻系统负担
```

### 数据操作

**1. 创建直推关系**
```sql
-- 用户A（ID=user_a）邀请用户B（ID=user_b）升级AI代理
INSERT INTO referral_relationships (referrer_id, referee_id)
VALUES ('user_a', 'user_b')
ON CONFLICT (referee_id) DO NOTHING;  -- 防止重复
```

**2. 查询我的直推列表**
```sql
SELECT 
  u.id, 
  u.username, 
  u.created_at,
  r.created_at as referral_created_at
FROM referral_relationships r
JOIN users u ON r.referee_id = u.id
WHERE r.referrer_id = 'my_user_id'
  AND r.is_active = true
  AND u.is_agent = true
ORDER BY r.created_at DESC;
```

**3. 查询我的推荐人**
```sql
SELECT 
  u.id, 
  u.username
FROM referral_relationships r
JOIN users u ON r.referrer_id = u.id
WHERE r.referee_id = 'my_user_id'
  AND r.is_active = true;
```

**4. 统计直推人数**
```sql
SELECT COUNT(*) as direct_count
FROM referral_relationships
WHERE referrer_id = 'my_user_id'
  AND is_active = true;
```

### 直推关系的两大用途

#### 用途1️⃣: **加速释放率计算**

```typescript
// 计算释放率
function calculateReleaseRate(userId: string): number {
  // 1. 查询直推人数
  const directCount = await supabase
    .from('referral_relationships')
    .select('*', { count: 'exact' })
    .eq('referrer_id', userId)
    .eq('is_active', true)
  
  // 2. 计算加速率
  const baseRate = 0.01      // 基础1%
  const boostRate = Math.min(directCount * 0.03, 0.15)  // 每人+3%，最高15%
  
  return baseRate + boostRate
}

// 示例：
// 0个直推 → 1%
// 1个直推 → 1% + 3% = 4%
// 2个直推 → 1% + 6% = 7%
// 3个直推 → 1% + 9% = 10%
// 4个直推 → 1% + 12% = 13%
// 5个直推 → 1% + 15% = 16%（封顶15%）
```

#### 用途2️⃣: **见单奖（推荐奖）**

```typescript
// 见单奖逻辑
async function onNewAgentJoined(newUserId: string, referrerId: string) {
  // 1. 新用户升级AI代理（支付30U）
  // 2. 查询推荐人
  // 3. 发放见单奖给推荐人
  
  const REFERRAL_BONUS = 5  // 见单奖：5U
  
  await WalletManager.add(
    referrerId,
    REFERRAL_BONUS,
    'referral_bonus',
    `直推见单奖：推荐${newUser.username}升级AI代理`
  )
}
```

---

## 📈 积分释放系统

### 释放公式

```
每日释放积分 = 学习卡本金(100) × 释放率

释放率 = 基础释放率(1%) + 直推加速率

直推加速率 = 直推人数 × 3%，最高15%
```

### 积分分配

```
每日释放的积分分为两部分：
├─ 70% → U余额（可提现）
└─ 30% → 互转积分（可激活学习卡、可互转）

例如：
释放10积分 → 7U + 3互转积分
```

### 积分字段关系

```
points_balance（总积分）     = 所有学习卡累计释放的积分总和
                            = SUM(released_points) from learning_cards
                            = 只读字段，不直接修改

transfer_points（互转积分）  = 可用于互转和激活学习卡的积分
                            = 每日释放的30%
                            = 可以手动修改（消费、互转）

关系：
transfer_points ⊆ points_balance
```

### 每日释放流程

```sql
-- Edge Function: 每天凌晨2点执行

1. 查询所有活跃学习卡
SELECT * FROM learning_cards 
WHERE status = 'active' 
  AND is_active = true
  AND (last_release_date IS NULL OR last_release_date < CURRENT_DATE);

2. 对每张学习卡：
   a. 获取用户的直推人数
   b. 计算释放率
   c. 计算释放积分
   d. 分配积分（70%→U，30%→互转）
   e. 更新余额
   f. 记录流水
   g. 检查是否出局
```

### 代码实现

```typescript
async function dailyReleaseForCard(card: LearningCard) {
  // 1. 获取直推人数
  const { count: directCount } = await supabase
    .from('referral_relationships')
    .select('*', { count: 'exact' })
    .eq('referrer_id', card.user_id)
    .eq('is_active', true)
  
  // 2. 计算释放率
  const baseRate = 0.01
  const boostRate = Math.min(directCount * 0.03, 0.15)
  const releaseRate = baseRate + boostRate
  
  // 3. 计算释放积分
  const releaseAmount = 100 * releaseRate
  
  // 4. 分配积分
  const toU = releaseAmount * 0.7
  const toTransfer = releaseAmount * 0.3
  
  // 5. 更新余额（使用RPC函数保证原子性）
  await supabase.rpc('add_user_balance', {
    p_user_id: card.user_id,
    p_amount: toU
  })
  
  await supabase.rpc('add_transfer_points', {
    p_user_id: card.user_id,
    p_amount: toTransfer
  })
  
  // 6. 更新学习卡
  await supabase
    .from('learning_cards')
    .update({
      released_points: card.released_points + releaseAmount,
      last_release_date: new Date().toISOString().split('T')[0]
    })
    .eq('id', card.id)
  
  // 7. 记录流水
  await TransactionLogger.log({
    user_id: card.user_id,
    type: 'daily_release',
    amount: toU,
    description: `学习卡每日释放: ${releaseAmount.toFixed(2)}积分 (释放率${(releaseRate*100).toFixed(1)}%)`,
    currency: 'U',
    metadata: {
      card_id: card.id,
      release_rate: releaseRate,
      direct_count: directCount,
      to_u: toU,
      to_transfer: toTransfer
    }
  })
  
  // 8. 检查出局
  if (card.released_points >= card.total_points) {
    await supabase
      .from('learning_cards')
      .update({ 
        status: 'completed',
        is_active: false,
        expires_at: new Date().toISOString()
      })
      .eq('id', card.id)
  }
}
```

---

## 🔄 Binary对碰系统

### Binary系统 vs 直推关系

```
┌─────────────────────┬──────────────────────────────────┐
│      特征           │   直推关系    │   Binary系统      │
├─────────────────────┼───────────────┼──────────────────┤
│  关系类型           │  业务关系     │   技术关系       │
│  建立方式           │  人工选择     │   系统自动排线   │
│  数据表             │  referral_    │   binary_members │
│                     │  relationships│                  │
│  关系字段           │  referrer_id  │   upline_id      │
│  用途               │  见单奖、加速 │   对碰奖、平级奖 │
│  是否可能不同       │  ✅ 是        │                  │
└─────────────────────┴───────────────┴──────────────────┘

例如：
- 用户A邀请用户B升级代理（直推关系）
  referral: B.referrer_id = A
  
- 但系统可能把B排到C的下面（Binary关系）
  binary: B.upline_id = C (因为C的弱区需要人)
```

### Binary排线规则

```
1. 优先放在推荐人（referrer）的弱区
2. 如果推荐人没有加入Binary，放在创世节点
3. 弱区优先：A区少放A区，B区少放B区
4. 1:1平衡原则
```

### 升级AI代理时的完整流程

```typescript
async function becomeAgent(userId: string, inviteCode: string) {
  // 1. 验证邀请码，获取推荐人
  const referrer = await getUserByInviteCode(inviteCode)
  
  // 2. 扣除30U
  await WalletManager.deduct(userId, 30, 'agent_purchase', '升级AI代理')
  
  // 3. 设置为AI代理
  await supabase
    .from('users')
    .update({ is_agent: true })
    .eq('id', userId)
  
  // 4. ⭐ 建立直推关系（写入referral_relationships表）
  await supabase
    .from('referral_relationships')
    .insert({
      referrer_id: referrer.id,
      referee_id: userId
    })
  
  // 5. 赠送100互转积分
  await WalletManager.addTransferPoints(userId, 100, 'binary_auto_gift', '赠送100互转积分')
  
  // 6. ⭐ 加入Binary系统（写入binary_members表）
  setTimeout(async () => {
    const placement = await findBestPlacement(referrer.id)
    await supabase
      .from('binary_members')
      .insert({
        user_id: userId,
        upline_id: placement.uplineId,  // 注意：可能 ≠ referrer.id
        position_side: placement.side,
        position_depth: placement.depth
      })
  }, 100)
  
  // 7. 发放见单奖给推荐人
  await WalletManager.add(
    referrer.id, 
    5, 
    'referral_bonus', 
    `直推见单奖`
  )
  
  return { success: true }
}
```

---

## 🔀 数据流转图

### 用户升级AI代理

```
用户填写邀请码提交
    ↓
验证邀请码有效性
    ↓
扣除30U余额
    ↓
┌─────────────────────────────────────────┐
│  并行执行4个操作（Promise.all）          │
├─────────────────────────────────────────┤
│ 1. users表：设置is_agent=true           │
│ 2. referral_relationships：建立直推关系 │
│ 3. 赠送100互转积分                      │
│ 4. 发放5U见单奖给推荐人                 │
└─────────────────────────────────────────┘
    ↓
后台异步（100ms后）
    ↓
加入Binary系统（binary_members表）
    ↓
完成
```

### 每日积分释放

```
凌晨2点 Edge Function触发
    ↓
查询所有活跃学习卡
    ↓
FOR EACH 学习卡:
    ↓
    1. 查询直推人数（referral_relationships）
    ↓
    2. 计算释放率 = 1% + 直推人数*3%
    ↓
    3. 计算释放积分 = 100 * 释放率
    ↓
    4. 分配积分：70%→U余额，30%→互转积分
    ↓
    5. 调用RPC更新余额（原子操作）
    ↓
    6. 记录交易流水（transactions表）
    ↓
    7. 更新学习卡释放记录
    ↓
    8. 检查是否出局（released >= total）
    ↓
完成
```

---

## ✅ 关键问题的明确答案

### Q1: 直推关系何时建立？
**A:** 升级AI代理时，填写邀请码后建立（写入`referral_relationships`表）

### Q2: points_balance vs transfer_points？
**A:** 
- `points_balance` = 只读，学习卡累计释放总和
- `transfer_points` = 可读写，每日释放的30%，可用于激活学习卡和互转

### Q3: inviter_id vs upline_id？
**A:**
- `referral_relationships.referrer_id` = 业务推荐人（人工选择）
- `binary_members.upline_id` = Binary系统上级（自动排线）
- 两者可能不同！

### Q4: 直推关系的用途？
**A:**
1. 计算加速释放率（每个直推+3%，最高15%）
2. 发放见单奖（推荐一个人升级代理，获得5U）

### Q5: 为什么要独立的直推关系表？
**A:**
1. 业务清晰：直推是业务关系，应独立管理
2. 查询高效：专门的表，索引优化
3. 历史追溯：可记录关系变化历史
4. 扩展性强：未来可加统计字段

---

## 📝 下一步行动

### 1. 数据库迁移
- [ ] 创建 `referral_relationships` 表
- [ ] 修改 `transactions.description` 字段长度为500
- [ ] 创建相关索引和约束

### 2. 代码重构
- [ ] `AgentService.becomeAgent()` - 使用直推关系表
- [ ] `MiningService.dailyRelease()` - 从直推关系表查询直推人数
- [ ] `TeamView.vue` - 从直推关系表查询团队数据

### 3. 测试验证
- [ ] 测试升级代理流程
- [ ] 测试直推人数统计
- [ ] 测试释放率计算
- [ ] 测试见单奖发放

---

**文档状态：** ✅ 架构设计完成，待实施

